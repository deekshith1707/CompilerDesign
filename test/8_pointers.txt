// Test case for pointers
#include <stdio.h>
#include <stdlib.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 10, y = 20;
    float f = 3.14;
    char c = 'A';
    
    int* ptr1;                     
    int *ptr2;                      
    float* fptr;                   
    char* cptr;                    
    
    ptr1 = &x;                     
    ptr2 = &y;
    fptr = &f;
    cptr = &c;
    
    // Pointer dereferencing
    int value1 = *ptr1;             
    *ptr1 = 30;                    
    printf("x = %d, *ptr1 = %d\n", x, *ptr1);
    
    // Pointer arithmetic
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int* aptr = arr;                // Array name as pointer
    
    printf("First element: %d\n", *aptr);
    printf("Second element: %d\n", *(aptr + 1));
    printf("Third element: %d\n", aptr[2]);  // Array notation with pointer
    
    // Pointer increment/decrement
    aptr++;                         
    printf("After increment: %d\n", *aptr);
    aptr--;                    
    printf("After decrement: %d\n", *aptr);
    
    // Pointer comparison
    int* ptr3 = &arr[5];
    if (aptr < ptr3) {
        printf("aptr points to earlier element\n");
    }
    
    // Pointer difference
    int diff = ptr3 - aptr;
    printf("Difference: %d elements\n", diff);
    
    // Multiple levels of indirection
    int** pptr = &ptr1;             // Pointer to pointer
    printf("Value through double pointer: %d\n", **pptr);
    
    // Null pointer
    int* null_ptr = NULL;
    if (null_ptr == NULL) {
        printf("Pointer is NULL\n");
    }
    
    // Pointer to different types
    void* vptr;                     
    vptr = &x;                     
    vptr = &f;
    // int val = *vptr;             // ERROR: cannot dereference void*
    int val = *(int*)vptr;          
    
    // Function pointers
    int (*func_ptr)(int, int) = add;
    int result = func_ptr(5, 3);
    printf("Function result: %d\n", result);
    
    // Const pointers
    const int* const_ptr = &x;      
    int* const ptr_const = &x;    
    const int* const const_both = &x;
    
    // *const_ptr = 50;             // ERROR: cannot modify const data
    // ptr_const = &y;              // ERROR: cannot modify const pointer
    
    // String pointers
    char* str1 = "Hello";         
    char str2[] = "World";         
    char* str3 = str2;              
    
    printf("String: %s\n", str1);
    printf("Character: %c\n", *str3);

    /*
    // Type errors (should be caught by semantic analyzer)
    int* ptr = 100;              // ERROR: cannot assign int to pointer
    int x = ptr1;                // ERROR: cannot assign pointer to int
    int result = ptr1 + ptr2;    // ERROR: cannot add two pointers
    ptr1 = ptr1 * 2;             // ERROR: cannot multiply pointer
    */

    return 0;
}
